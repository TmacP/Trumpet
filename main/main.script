local conductor = require "main.conductor"

local speed = 300

function init(self)
	-- Acquire input and set up projection
	msg.post(".", "acquire_input_focus")
	msg.post("@render:", "use_fixed_fit_projection", { near = -1, far = 1 })

	-- Play the song with a callback function
	sound.play("song#sound", {}, function(self, message_id, message, sender)
		if message_id == hash("sound_done") then
			print("Sound has finished playing!")
			on_sound_done(self) -- Call a custom function for cleanup or further logic
		elseif message_id == hash("sound_stopped") then
			print("Sound was stopped manually.")
		end
	end)

	-- Initialize variables for spawning
	self.spawn_interval = conductor.get_crotchet()
	self.time_since_last_spawn = 0
	self.factory_url = "#note" -- Factory URL

	-- Table to keep track of spawned notes
	self.notes = {}
	self.note_speed = speed -- Speed should be distance to target / 2
end

function update(self, dt)
	-- Update conductor timing
	conductor.update(dt)

	-- Update time since the last note spawn
	self.time_since_last_spawn = self.time_since_last_spawn + dt

	if self.time_since_last_spawn >= self.spawn_interval then
		-- Determine a random variation (0 to 7)
		local variation = math.random(0, 7)

		-- Spawn the note
		local note_id = factory.create(self.factory_url, vmath.vector3(100, 640, 0)) -- Adjust position as needed

		-- Send the variation to the note script
		msg.post(note_id, "set_variation", { variation = variation })

		-- Track the note
		table.insert(self.notes, note_id)
		self.time_since_last_spawn = 0
	end

	-- Move notes
	for i = #self.notes, 1, -1 do
		local note_id = self.notes[i]
		if go.exists(note_id) then
			-- Move the note downward
			local position = go.get_position(note_id)
			position.y = position.y - (self.note_speed * dt)
			go.set_position(position, note_id)

			-- Remove notes that move off-screen
			if position.y < 120 then -- Adjust based on screen size
				go.delete(note_id)
				table.remove(self.notes, i)
			end
		else
			-- Remove invalid notes from the list
			table.remove(self.notes, i)
		end
	end
end

function on_input(self, action_id, action)
	-- Handle touch input for hit detection
	if action_id == hash("touch") and action.pressed then
		-- Get the current song position in seconds
		local current_time = conductor.song_position

		-- Snap the current time to the nearest beat using the conductor
		local nearest_beat_time = conductor.snap_to_beat(current_time)

		-- Allow a small margin of error (e.g., 0.1 seconds) for the player to hit the beat
		local margin_of_error = 0.1
		if math.abs(current_time - nearest_beat_time) < margin_of_error then
			print("Hit detected on beat!")

			-- Check which note is closest to the player and notify it
			for _, note_id in ipairs(self.notes) do
				if go.exists(note_id) then
					msg.post(note_id, "on_hit")
					break -- Only handle one note per touch
				end
			end
		else
			print("Missed the beat!")
		end
	end
end

-- Custom logic for when the sound finishes
function on_sound_done(self)
	print("Handle end-of-sound logic here.")
	-- Example: Transition to a new scene or restart gameplay
end
